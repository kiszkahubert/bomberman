<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org" lang="en">
<head>
    <meta charset="UTF-8">
    <title>Bomberman</title>
    <style>
        canvas{
            border: 2px solid black;
            background-color: black;
        }
    </style>
</head>
<body>
    <canvas id="game" width="900" height="900"></canvas>
    <script th:inline="javascript">
        /*<![CDATA[*/
        const gameState = /*[[${gameState}]]*/ null;
        const gameId = /*[[${gameId}]]*/ '';
        const playerId = /*[[${playerId}]]*/ '';
        /*]]>*/
    </script>
    <script>
        const canvas = document.getElementById('game');
        canvas.focus();
        const ctx = canvas.getContext('2d');
        const keysPressed = {};
        window.addEventListener('keydown', (e)=>{
            keysPressed[e.key] = true;
            handleMovement();
        })
        window.addEventListener('keyup', (e)=>{
            keysPressed[e.key] = false;
        })
        function handleMovement(){
            const currentPlayer = gameState.players.find(p => p.id.toString() === playerId);
            if(!currentPlayer) return;
            let newX = currentPlayer.x;
            let newY = currentPlayer.y;
            console.log("Current position:", newX, newY);
            const moveAmount = 60;
            if(keysPressed['ArrowUp']) newY -= moveAmount;
            if(keysPressed['ArrowDown']) newY += moveAmount;
            if(keysPressed['ArrowLeft']) newX -= moveAmount;
            if(keysPressed['ArrowRight']) newX += moveAmount;
            if(newX !== currentPlayer.x || newY !== currentPlayer.y){
                if(!checkCollision(newX,newY)){
                    updateGameState(newX, newY)
                }
                // sendMoveToServer(newX,newY)
            }
        }

        /**
         *
         * @param x new X position of player
         * @param y new Y position of player
         * @returns {boolean} False means there is no collision
         */
        function checkCollision(x,y){
            var blocks = gameState.gameMap.gameMap;
            for(const [key, value] of Object.entries(blocks)){
                const [mapX,mapY] = key.split(',').map(Number);
                if(x === mapX && y === mapY && !value){
                    return false;
                } else if(x === mapX && y === mapY){
                    return true;
                }
            }
            return true;
        }
        function updateGameState(x,y){
            const currentPlayer = gameState.players.find(p => p.id.toString() === playerId);
            if (currentPlayer) {
                currentPlayer.x = x;
                currentPlayer.y = y;
                drawInitialBoard()
            }
        }
        // function sendMoveToServer(x,y){
        //     //TODO implement this endpoint and optimize rendering
        //     fetch(`/game/${gameId}/move`,{
        //         method: 'POST',
        //         headers: {
        //             'Content-Type': 'application/json',
        //         },
        //         body: JSON.stringify({
        //             playerId: playerId,
        //             x: x,
        //             y: y
        //         })
        //     }).then(response => response.json())
        //         .then(updatedGameState => {
        //             gameState = updatedGameState;
        //             drawInitialBoard();
        //         })
        //         .catch(error => {
        //             console.error(error);
        //         });
        // }

        function drawPlayers(){
            ctx.fillStyle = 'pink';
            ctx.strokeStyle = 'yellow';
            ctx.lineWidth = 2;
            var players = gameState.players;
            players.forEach(el => {
                drawBorderedRect(el.x,el.y)
            })
        }
        function drawBlocks(){
            var blocks = gameState.gameMap.gameMap;
            for(const [key, value] of Object.entries(blocks)){
                const [x,y] = key.split(',').map(Number);
                if(value){
                    ctx.fillStyle = 'yellow';
                    ctx.strokeStyle = 'yellow';
                    ctx.lineWidth = 2;
                    drawBorderedRect(x, y);
                }
            }
        }
        //each square 60x60
        function drawBorder() {
            ctx.fillStyle = 'blue';
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            for (let i = 0; i < 15; i++) {
                drawBorderedRect(60 * i, 0);
            }
            for (let i = 1; i < 15; i++) {
                drawBorderedRect(0, 60 * i);
            }
            for (let i = 0; i < 15; i++) {
                drawBorderedRect(60 + 60 * i, 840);
            }
            for (let i = 0; i < 15; i++) {
                drawBorderedRect(840, 60 + 60 * i);
            }
        }
        function drawInnerSquares(){
            ctx.fillStyle = 'blue';
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            for(let i=0;i<6;i++){
                for(let j=0;j<6;j++){
                    drawBorderedRect(120+120*j,120+120*i);
                }
            }
        }
        function drawBorderedRect(x, y) {
            ctx.fillRect(x, y, 60, 60);
            ctx.strokeRect(x, y, 60, 60);
        }
        function drawInitialBoard(){
            ctx.clearRect(0,0, canvas.width, canvas.height);
            drawBorder()
            drawInnerSquares()
            drawPlayers()
            drawBlocks()
        }
        drawInitialBoard()
    </script>
</body>
</html>